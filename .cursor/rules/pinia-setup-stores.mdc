---
description: "Règles pour l'utilisation des Setup Stores Pinia dans le projet FEMAT"
globs: *.vue,*.ts,*.js
---

# Pinia Setup Stores - Règles de Développement FEMAT

## Configuration Pinia

Le projet FEMAT utilise **Pinia Setup Stores** selon la [documentation officielle](https://pinia.vuejs.org/core-concepts/#Setup-Stores).

### Syntaxe Setup Stores Obligatoire

```typescript
// ✅ CORRECT - Setup Store syntax
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const name = ref('Eduardo')
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, name, doubleCount, increment }
})
```

### ❌ Éviter Option Stores

```typescript
// ❌ ÉVITER - Option Store syntax
export const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0, name: 'Eduardo' }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

## Règles de Développement

### 1. Structure des Stores
- **Utiliser `defineStore()`** avec fonction setup
- **Nommage** : `use[Name]Store` (ex: `useUIStore`, `useContentStore`)
- **ID unique** : Premier argument de `defineStore()`
- **Return obligatoire** : Toutes les propriétés d'état doivent être retournées

### 2. État (State)
```typescript
// ✅ CORRECT
const count = ref(0)
const name = ref('Eduardo')

// ❌ ÉVITER - Propriétés privées
const privateData = ref('secret') // Ne pas retourner
```

### 3. Getters (Computed)
```typescript
// ✅ CORRECT
const doubleCount = computed(() => count.value * 2)
const formattedName = computed(() => name.value.toUpperCase())
```

### 4. Actions (Functions)
```typescript
// ✅ CORRECT
function increment() {
  count.value++
}

function updateName(newName: string) {
  name.value = newName
}
```

### 5. Utilisation dans les Composants
```vue
<script setup>
import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'

const store = useCounterStore()

// ✅ Destructuring réactif
const { count, name, doubleCount } = storeToRefs(store)
const { increment, updateName } = store

// ❌ ÉVITER - Destructuring direct
const { count, name } = store // Perd la réactivité
</script>
```

## Exemples de Stores FEMAT

### Stores UI (Interface)
```typescript
// stores/ui.ts
export const useUIStore = defineStore('ui', () => {
  const isMenuOpen = ref(false)
  const theme = ref('light')
  const language = ref('fr')
  
  const toggleMenu = () => {
    isMenuOpen.value = !isMenuOpen.value
  }
  
  const setTheme = (newTheme: string) => {
    theme.value = newTheme
  }
  
  return { isMenuOpen, theme, language, toggleMenu, setTheme }
})
```

### Stores Content (Contenu)
```typescript
// stores/content.ts
export const useContentStore = defineStore('content', () => {
  const currentPage = ref('')
  const breadcrumbs = ref([])
  const isLoading = ref(false)
  
  const setCurrentPage = (page: string) => {
    currentPage.value = page
  }
  
  const setBreadcrumbs = (crumbs: string[]) => {
    breadcrumbs.value = crumbs
  }
  
  return { currentPage, breadcrumbs, isLoading, setCurrentPage, setBreadcrumbs }
})
```

### Stores Navigation (Navigation)
```typescript
// stores/navigation.ts
export const useNavigationStore = defineStore('navigation', () => {
  const activeSection = ref('')
  const scrollPosition = ref(0)
  const isScrolling = ref(false)
  
  const setActiveSection = (section: string) => {
    activeSection.value = section
  }
  
  const updateScrollPosition = (position: number) => {
    scrollPosition.value = position
  }
  
  return { activeSection, scrollPosition, isScrolling, setActiveSection, updateScrollPosition }
})
```

## Avantages Setup Stores

### 1. Flexibilité
- **Composables** : Utiliser `useRoute()`, `inject()`, etc.
- **Watchers** : Créer des watchers dans les stores
- **Logique complexe** : Plus de liberté pour organiser le code

### 2. TypeScript
- **Inférence automatique** : Types générés automatiquement
- **IntelliSense** : Autocomplétion complète
- **Sécurité** : Vérification des types à la compilation

### 3. Performance
- **Tree shaking** : Bundler peut optimiser le code
- **Lazy loading** : Chargement à la demande
- **SSR** : Meilleur support pour le rendu côté serveur

## Bonnes Pratiques

### 1. Fichiers Séparés
```typescript
// ✅ CORRECT - Un store par fichier
// stores/ui.ts
export const useUIStore = defineStore('ui', () => {
  // ...
})

// stores/content.ts  
export const useContentStore = defineStore('content', () => {
  // ...
})
```

### 2. Naming Convention
- **Store ID** : `'ui'`, `'content'`, `'navigation'`
- **Function name** : `useUIStore`, `useContentStore`, `useNavigationStore`
- **File name** : `ui.ts`, `content.ts`, `navigation.ts`

### 3. Return Obligatoire
```typescript
// ✅ CORRECT - Tout est retourné
return { 
  // State
  count, 
  name,
  // Getters  
  doubleCount,
  // Actions
  increment,
  updateName 
}
```

### 4. Éviter les Propriétés Privées
```typescript
// ❌ ÉVITER - Propriétés non retournées
const privateData = ref('secret')
// Ne pas retourner privateData

// ✅ CORRECT - Toutes les propriétés publiques
return { publicData, publicMethod }
```

## Intégration avec Nuxt

### Configuration nuxt.config.ts
```typescript
export default defineNuxtConfig({
  modules: [
    '@pinia/nuxt'
  ]
})
```

### Auto-imports
```typescript
// ✅ CORRECT - Auto-import disponible
const store = useUIStore() // Pas besoin d'import
```

## Références

- [Documentation Pinia Setup Stores](https://pinia.vuejs.org/core-concepts/#Setup-Stores)
- [Pinia avec Nuxt](https://pinia.vuejs.org/ssr/nuxt.html)
- [StoreToRefs](https://pinia.vuejs.org/core-concepts/#using-the-store)
- [Architecture FEMAT](mdc:architecture.md)
- [TODO.md](mdc:TODO.md)